import Vapor
import Fluent
import CMSObjects
import CMSSchema

// MARK: - Swift SDK Generator

/// Generates a Swift client SDK for the SwiftCMS API.
///
/// This generator introspects content type definitions and generates
/// type-safe Swift code for interacting with the API.
public actor SwiftSDKGenerator {

    /// Generate the complete Swift SDK.
    public func generate(
        contentTypes: [ContentTypeDefinition],
        apiBaseURL: String
    ) async throws -> String {
        var output = ""

        // Header
        output += generateHeader(apiBaseURL: apiBaseURL)

        // Models
        output += generateModels(contentTypes: contentTypes)

        // API Client
        output += generateClient(contentTypes: contentTypes)

        // Extensions
        output += generateExtensions()

        return output
    }

    /// Generate the file header.
    private func generateHeader(apiBaseURL: String) -> String {
        return """
        //
        //  SwiftCMS Swift Client SDK
        //  Generated by SwiftCMS OpenAPI Generator
        //
        //  @version 1.0.0
        //

        import Foundation

        /// Configuration for the SwiftCMS client.
        public struct SwiftCMSConfiguration {
            public let baseURL: URL
            public let timeout: TimeInterval
            public var authorization: String?

            public init(
                baseURL: String = "\(apiBaseURL)",
                timeout: TimeInterval = 30.0,
                authorization: String? = nil
            ) {
                guard let url = URL(string: baseURL) else {
                    fatalError("Invalid base URL: \\(baseURL)")
                }
                self.baseURL = url
                self.timeout = timeout
                self.authorization = authorization
            }
        }

        /// Error types for API responses.
        public enum SwiftCMSError: Error, LocalizedError {
            case invalidResponse(URLResponse, Data?)
            case networkError(Error)
            case decodingError(Error)
            case apiError(status: Int, reason: String)

            public var errorDescription: String? {
                switch self {
                case .invalidResponse(let response, let data):
                    if let data = data,
                       let message = String(data: data, encoding: .utf8) {
                        return "HTTP \\(response.statusCode): \\(message)"
                    }
                    return "HTTP \\(response.statusCode)"
                case .networkError(let error):
                    return "Network error: \\(error.localizedDescription)"
                case .decodingError(let error):
                    return "Decoding error: \\(error.localizedDescription)"
                case .apiError(let status, let reason):
                    return "API error (\\(status)): \\(reason)"
                }
            }
        }

        """
    }

    /// Generate Swift models for content types.
    private func generateModels(contentTypes: [ContentTypeDefinition]) -> String {
        var output = "// MARK: - Models\\n\\n"

        // Pagination models
        output += """
        /// Pagination metadata.
        public struct PaginationMeta: Codable, Sendable {
            public let page: Int
            public let perPage: Int
            public let total: Int
            public let totalPages: Int
        }

        /// Paginated response wrapper.
        public struct PaginatedResponse<T: Codable>: Codable, Sendable {
            public let data: [T]
            public let meta: PaginationMeta
        }

        /// Content entry base.
        public struct ContentEntry: Codable, Sendable {
            public let id: UUID
            public let contentType: String
            public let status: String
            public let data: [String: AnyCodableValue]
            public let locale: String
            public let createdAt: Date?
            public let updatedAt: Date?
            public let publishedAt: Date?
            public let createdBy: String?
        }

        """

        // Content type models
        for contentType in contentTypes {
            output += generateModel(from: contentType)
        }

        return output
    }

    /// Generate a Swift struct for a single content type.
    private func generateModel(from contentType: ContentTypeDefinition) -> String {
        let typeName = typeNameFromSlug(contentType.slug)
        var output = "/// \\(contentType.displayName)\\n"
        output += "public struct \\(typeName): Codable, Sendable {\\n"

        guard case let .dictionary(jsonSchema) = contentType.jsonSchema else {
            output += "    // Invalid schema\\n}\\n\\n"
            return output
        }

        if let properties = jsonSchema["properties"]?.dictionaryValue {
            for fieldName in properties.keys.sorted() {
                guard let fieldSchema = properties[fieldName],
                      let dict = fieldSchema.dictionaryValue,
                      let type = dict["type"]?.stringValue else {
                    continue
                }

                let description = dict["description"]?.stringValue ?? ""
                let swiftType = swiftType(from: dict, type: type)

                output += "    /// \\(description)\\n"
                output += "    public let \\(fieldName.camelize()): \\(swiftType)\\n"
            }
        }

        output += "}\\n\\n"

        // Also generate the Data struct (just the data portion)
        let dataTypeName = "\\(typeName)Data"
        output += "/// \\(contentType.displayName) data\\n"
        output += "public struct \\(dataTypeName): Codable, Sendable {\\n"

        if let properties = jsonSchema["properties"]?.dictionaryValue {
            for fieldName in properties.keys.sorted() {
                guard let fieldSchema = properties[fieldName],
                      let dict = fieldSchema.dictionaryValue,
                      let type = dict["type"]?.stringValue else {
                    continue
                }

                let swiftType = swiftType(from: dict, type: type)
                output += "    public let \\(fieldName.camelize()): \\(swiftType)\\n"
            }
        }

        output += "}\\n\\n"

        return output
    }

    /// Convert JSON Schema type to Swift type.
    private func swiftType(from dict: [String: AnyCodableValue], type: String) -> String {
        switch type {
        case "string":
            let format = dict["format"]?.stringValue
            if format == "email" { return "String" }
            if format == "date" || format == "date-time" { return "Date" }
            if format == "uuid" { return "UUID" }
            return "String"

        case "integer":
            return "Int"

        case "number":
            return "Double"

        case "boolean":
            return "Bool"

        case "array":
            if let items = dict["items"]?.dictionaryValue,
               let itemType = items["type"]?.stringValue {
                let innerType = swiftType(from: items, type: itemType)
                return "[\\(innerType)]"
            }
            return "[AnyCodableValue]"

        case "object":
            return "[String: AnyCodableValue]"

        default:
            return "String"
        }
    }

    /// Generate the API client class.
    private func generateClient(contentTypes: [ContentTypeDefinition]) -> String {
        var output = """
        // MARK: - API Client

        /// SwiftCMS API client.
        public actor SwiftCMSClient {
            private let configuration: SwiftCMSConfiguration
            private let session: URLSession = .shared

            public init(configuration: SwiftCMSConfiguration) {
                self.configuration = configuration
            }

            private func performRequest<T: Decodable>(
                method: String,
                path: String,
                body: Encodable? = nil,
                query: [String: String]? = nil
            ) async throws -> T {
                var components = URLComponents(url: configuration.baseURL.appendingPathComponent(path), resolvingAgainstBaseURL: configuration.baseURL)
                components.queryItems = query?.map { URLQueryItem(name: $0.key, value: $0.value) }

                guard let url = components.url else {
                    throw SwiftCMSError.networkError(URLError(.badURL))
                }

                var request = URLRequest(url: url)
                request.httpMethod = method

                if let body = body {
                    request.httpBody = try JSONEncoder().encode(body)
                    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                }

                if let auth = configuration.authorization {
                    request.setValue("Bearer \\(auth)", forHTTPHeaderField: "Authorization")
                }

                request.timeoutInterval = configuration.timeout

                let (data, response) = try await session.data(for: request)

                guard (200...299).contains(response.statusCode) else {
                    throw SwiftCMSError.invalidResponse(response, data)
                }

                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601

                do {
                    return try decoder.decode(T.self, from: data)
                } catch {
                    throw SwiftCMSError.decodingError(error)
                }
            }

        """

        // Generate CRUD methods for each content type
        for contentType in contentTypes {
            let typeName = typeNameFromSlug(contentType.slug)
            let singularName = singularize(typeName)
            let slug = contentType.slug

            output += """
            // ========== \\(contentType.displayName) ==========

            /// List all \\(contentType.displayName).
            /// - Parameters:
            ///   - page: Page number (default: 1)
            ///   - perPage: Items per page (default: 20)
            ///   - status: Filter by status
            ///   - locale: Filter by locale
            /// - Returns: Paginated list of \\(singularName)
            public func list\\(typeName)(
                page: Int = 1,
                perPage: Int = 20,
                status: String? = nil,
                locale: String? = nil
            ) async throws -> PaginatedResponse<\\(typeName)Data> {
                var query: [String: String] = [:]
                query["page"] = String(page)
                query["perPage"] = String(perPage)
                if let status = status { query["status"] = status }
                if let locale = locale { query["locale"] = locale }

                return try await performRequest(
                    method: "GET",
                    path: "/api/v1/\\(slug)",
                    query: query
                )
            }

            /// Get a single \\(singularName) by ID.
            public func get\\(typeName)(id: UUID) async throws -> \\(typeName)Data {
                return try await performRequest(
                    method: "GET",
                    path: "/api/v1/\\(slug)/\\(id.uuidString)"
                )
            }

            /// Create a new \\(singularName).
            public func create\\(typeName)(_ data: \\(typeName)Data) async throws -> \\(typeName)Data {
                return try await performRequest(
                    method: "POST",
                    path: "/api/v1/\\(slug)",
                    body: data
                )
            }

            /// Update a \\(singularName).
            public func update\\(typeName)(
                id: UUID,
                data: \\(typeName)Data
            ) async throws -> \\(typeName)Data {
                return try await performRequest(
                    method: "PUT",
                    path: "/api/v1/\\(slug)/\\(id.uuidString)",
                    body: data
                )
            }

            /// Delete a \\(singularName).
            public func delete\\(typeName)(id: UUID) async throws {
                let _: EmptyResponse = try await performRequest(
                    method: "DELETE",
                    path: "/api/v1/\\(slug)/\\(id.uuidString)"
                )
            }

            /// Publish a \\(singularName).
            public func publish\\(typeName)(id: UUID) async throws -> \\(typeName)Data {
                let _: PublishResponse = try await performRequest(
                    method: "POST",
                    path: "/api/v1/\\(slug)/\\(id.uuidString)/publish"
                )
                return try await get\\(typeName)(id: id)
            }

            /// Unpublish a \\(singularName).
            public func unpublish\\(typeName)(id: UUID) async throws -> \\(typeName)Data {
                let _: UnpublishResponse = try await performRequest(
                    method: "POST",
                    path: "/api/v1/\\(slug)/\\(id.uuidString)/unpublish"
                )
                return try await get\\(typeName)(id: id)
            }

            """
        }

        output += "}// End of SwiftCMSClient\\n"
        return output
    }

    /// Generate helper extensions.
    private func generateExtensions() -> String {
        return """
        // MARK: - Extensions

        /// Empty response for DELETE operations.
        private struct EmptyResponse: Codable, Sendable {}

        /// Publish response.
        private struct PublishResponse: Codable, Sendable {
            public let publishedAt: Date
        }

        /// Unpublish response.
        private struct UnpublishResponse: Codable, Sendable {
            public let unpublishedAt: Date
        }

        extension String {
            /// Convert snake_case to camelCase.
            func camelize() -> String {
                return self.split(separator: "_")
                    .enumerated()
                    .map { $0.element.lowercased() + ($0.offset > 0 ? $0.element.capitalized : "") }
                    .joined()
            }

            /// Convert kebab-case to camelCase.
            func kebabToCamel() -> String {
                return self.split(separator: "-")
                    .enumerated()
                    .map { $0.element.lowercased() + ($0.offset > 0 ? $0.element.capitalized : "") }
                    .joined()
            }
        }

        """
    }

    /// Convert a slug to a Swift type name (PascalCase).
    private func typeNameFromSlug(_ slug: String) -> String {
        return slug
            .split(separator: "_")
            .map { $0.capitalized }
            .joined()
    }

    /// Singularize a plural word.
    private func singularize(_ word: String) -> String {
        if word.hasSuffix("ies") {
            return String(word.dropLast(3)) + "y"
        } else if word.hasSuffix("es") {
            return String(word.dropLast(2))
        } else if word.hasSuffix("s") {
            return String(word.dropLast())
        }
        return word
    }
}
